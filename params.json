{
  "name": "Bit-loader",
  "tagline": "Framework for building module loaders with very little effort",
  "body": "<img src=\"https://raw.githubusercontent.com/MiguelCastillo/bit-loader/master/img/bit-loader_white.png\" width=\"100%\"></img>\r\n\r\n[![Build Status](https://travis-ci.org/MiguelCastillo/bit-loader.svg?branch=master)](https://travis-ci.org/MiguelCastillo/bit-loader) [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/MiguelCastillo/bit-loader?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n\r\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\r\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\r\n**Table of Contents**\r\n\r\n- [Introduction](#introduction)\r\n- [Examples](#examples)\r\n- [Install npm dependencies, build, and test](#install-npm-dependencies-build-and-test)\r\n- [Architecture Overview](#architecture-overview)\r\n  - [The first stage - the module loading stage](#the-first-stage---the-module-loading-stage)\r\n    - [5 pipelines](#5-pipelines)\r\n  - [The second stage - the module building stage](#the-second-stage---the-module-building-stage)\r\n- [Plugins](#plugins)\r\n- [Default providers](#default-providers)\r\n    - [Example](#example)\r\n- [Module Meta](#module-meta)\r\n    - [Pipeline Flow of the first and second stage](#pipeline-flow-of-the-first-and-second-stage)\r\n    - [Visual of fetch pipelines](#visual-of-fetch-pipelines)\r\n- [Pattern Matching](#pattern-matching)\r\n  - [match](#match)\r\n  - [ignore](#ignore)\r\n  - [extensions](#extensions)\r\n- [License](#license)\r\n\r\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\r\n\r\n\r\n## Introduction\r\n\r\n> Framework for building module loaders. This is the core library for [bit-imports](https://github.com/MiguelCastillo/bit-imports) and [bit-bundler](https://github.com/MiguelCastillo/bit-bundler).\r\n\r\n\r\n## Examples\r\n\r\nPlease checkout the [examples](https://github.com/MiguelCastillo/bit-loader/tree/master/example).  There you will find different recipes for setting things up.\r\n\r\n\r\n## Install npm dependencies, build, and test\r\n\r\n```\r\n$ npm install\r\n$ grunt build\r\n$ grunt test\r\n```\r\n\r\nAll build artifacts will be in the `dist` folder.\r\n\r\n\r\n## Architecture Overview\r\n\r\n`bit-loader` is composed of a two stage system. The first stage is responsible for loading and processing files via puggable pipelines. And a second stage is responsible for building (compiling and linking) modules.\r\n\r\n### The first stage - the module loading stage\r\n\r\nThis stage is responsible for loading files from storage and processing them in order to generate a graph, which we refer to as module graph. The module graph is basically a tree structure that outlines the dependency hierarchy of the modules.\r\n\r\nThis stage is composed of several pluggable pipelines that cascade *information* from one pipeline to the next. This *information* is encapsulated in an object we refer to as *module meta*. More information on the module meta objects can be found [here](#module-meta). The flow that module meta objects go through is described below:\r\n\r\nFirst, we need to convert module names to file paths in order to load modules from storage. This conversion is called *module name resolution*, which is done in the `resolve` pipeline. The `path` generated in the `resolve` pipeline is then used by the `fetch` pipeline to load module files from storage. These files are subsequently processed by the `transform` pipeline, which is generally where all transpilation/transformation is done. The result of the `transform` pipeline is pushed through the `dependency` pipeline, which pulls out dependencies and recursively feeds them through the first stage (module loading stage) until no more modules are left to load into the module graph. And finally, a helper pipeline called `precompile` that allows you to preemptively set the module `exports`, which effectively prevents modules from being processed in the build stage.\r\n\r\n> This stage is entirely asynchronous, and the output is a module graph.\r\n\r\n\r\n#### 5 pipelines\r\n\r\nThe module loading stage has 5 pipelines, which are described below.\r\n\r\n- **`resolve`** - responsible for generating paths to read module files from storage.\r\n- **`fetch`** - responsible for loading files from storage.\r\n- **`transform`** - responsible for processing and transforming loaded files.  E.g. ES2015 to ES5 via babeljs. Or CoffeeScript to JavaScript.\r\n- **`dependency`** - responsible for parsing out dependencies from the loaded files and recursively feeding them to the module loading stage.\r\n- **`precompile`** - provides you with a hook for preemptively building modules in the fetch stage, which effectively prevents module processing in the build stage.\r\n\r\nThese five pipelines are pluggable, which means that you can register handler functions to process module data in each one of them. These pipelines are executed sequentially in the order listed above, with each pipeline cascading data from one to the next. Furthermore, all these pipelines use Promises to orchestrate any asynchronous processing done by each configured handler.\r\n\r\nEach one of these pipelines (with the exception of precompile) has a corresponding pre and post companion. That means that resolve really provides you with `preresolve`, `resolve`, and `postresolve`.\r\n\r\nMore details on how to hook into these pipelines can be found in the [plugins](#plugins) section.\r\n\r\n> BTW - pipelines are internally known as `Services`\r\n\r\n### The second stage - the module building stage\r\n\r\nThe build stage (compile + linking) is where the *transformed files* are converted to *evaluated code*, which is what host applications generally consume.\r\n\r\n> The build stage is synchronous and it is *not* pluggable.\r\n\r\nThe combination of the first (*asynchronous*) stage with the second (*synchronous*) build stage enables support for `CJS`,`AMD`, and `ES6 modules` simultaneously.\r\n\r\n\r\n---\r\n\r\n\r\n## Plugins\r\n\r\nA plugin is a container with handler functions that hook into the pipelines in order to load and process modules.\r\n\r\n> A handler is fundamentally a `transform` as found in many other systems. However, it is called `handler` in `bit-loader` to prevent confusion with the `transform` pipeline.\r\n\r\nHandler arguments and return values are:\r\n\r\n- *param* { object } **`meta`** - Object with information to be processed. See [module meta](#module-meta).\r\n- *param* { object } **`options`** - Configuration object for the particular handler.\r\n- *param* { function } **`cancel`** - Function to cancel the execution of the plugin handlers for the particular pipeline the handler is executing on.\r\n- *returns* { object | Promise } Object with properties to be merged into the module meta object. Plugin handlers can alternatively return promises to control asynchronous data processing.\r\n\r\nThe example below is a plugin with a handler that hooks into the fetch pipeline to load modules from storage, and another handler that hooks into the transform pipeline to add `'use strict;'` to loaded modules.\r\n\r\n``` javascript\r\n// Plugin handler to load file from storage using the fetch API.\r\nfunction loadFile(meta, options, cancel) {\r\n  return window\r\n    .fetch(meta.path)\r\n    .then(function(response) {\r\n      return {\r\n        source: response.text();\r\n      };\r\n    });\r\n}\r\n\r\n// Plugin handler to add `use strict` to loaded modules\r\nfunction addStrict(meta, options, cancel) {\r\n  return {\r\n    source: \"'use strict;'\\n\" + meta.source\r\n  };\r\n}\r\n\r\n// Configure plugin with the two handlers\r\nbitloader.plugin({\r\n  fetch: loadFile,\r\n  transform: addStrict\r\n});\r\n```\r\n\r\nPlugins can take a single or an array of handlers, and a handler can be a module name (a string). When a handler is a module name, `bit-loader` will dynamically load it at runtime. The following example shows the handlers passed in as an array and one of the handlers is a module name.\r\n\r\n``` javascript\r\nbitloader.plugin({\r\n  fetch: [ loadFile ],\r\n  transform: [ \"add-strict\" ]\r\n});\r\n```\r\n\r\nWhen a handler is an object, a property `handler` is expected to be defined as either a module name or a function. Some of the reasons to define a plugin handler as an object is to specify options to be passed onto the `handler` function when it is executed and/or to configure pattern matching. See [pattern matching](#pattern-matching).\r\n\r\nThe example below configures a plugin handler as an object. Notice the `handler` is \"add-strict\" which is the name of the module to be dynamically loaded at runtime. The options for the handler is also forwarded to the `handler` function when it is invoked.\r\n\r\n``` javascript\r\nbitloader.plugin({\r\n  fetch: loadFile,\r\n  transform: {\r\n    handler: \"add-strict\",\r\n    options: {\r\n      inlineMap: true\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nPlugins also provide a way to define the shape of the modules your plugins can process via pattern matching. For example, you can specify properties like the module path, module name, or even match content in the module source. Below is an example configuring a plugin to only process files with `js` and `es6` extensions:\r\n\r\n``` javascript\r\nbitloader.plugin({\r\n  extensions: [\"js\", \"es6\"]\r\n});\r\n```\r\n\r\nWe did all the previous steps separately for illustration purposes, but we can certainly do all that stuff in a single call.\r\n\r\n``` javascript\r\nvar bitloader = new Bitloader();\r\n\r\nbitloader.plugin({\r\n  extensions: [\"js\", \"es6\"],\r\n  fetch: loadFile,\r\n  transform: addStrict\r\n});\r\n```\r\n\r\nOr alternatively, via `bit-loader`'s constructor\r\n\r\n``` javascript\r\nvar bitloader = new Bitloader({\r\n  plugins: [{\r\n    extensions: [\"js\", \"es6\"],\r\n    fetch: loadFile,\r\n    transform: addStrict\r\n  }]\r\n});\r\n```\r\n\r\n\r\n## Default providers\r\n\r\nAll pluggable pipelines have an optional default provider, which is just a default handler that is executed when no plugin can process a particular module. These are configured by providing the corresponding handlers in `bit-loader`'s constructor.\r\n\r\n> [bit imports](https://github.com/MiguelCastillo/bit-imports) and [bit-bundler](https://github.com/MiguelCastillo/bit-bundler) both implement default providers to give base functionality without configuring plugins.\r\n\r\n#### Example\r\n``` javascript\r\nfunction resolvePath(meta) {\r\n  return {\r\n    path: \"path/to/module/\" + meta.name\r\n  };\r\n}\r\n\r\nfunction loadFile(meta) {\r\n  return window\r\n    .fetch(meta.path)\r\n    .then(function(response) {\r\n      return {\r\n        source: response.text();\r\n      };\r\n    });\r\n}\r\n\r\n// The compilation is not pluggable. However, you can always set `exports` in\r\n// any stage to tell bit-loader that the module is ready for consumption.\r\nfunction compileModule(meta) {\r\n  return {\r\n    exports: eval(meta.source)\r\n  };\r\n}\r\n\r\n\r\n//\r\n// Instantiate bitloader with default providers.\r\n//\r\nvar bitloader = new Bitloader({\r\n  resolve    : resolvePath,\r\n  fetch      : loadFile,\r\n  precompile : compileModule\r\n});\r\n```\r\n\r\n## Module Meta\r\n\r\nSo what exactly are the different pipelines passing around anyways? They are passing around a module meta object, which is an object that contains the current state of the module. This object is an intermediate representation that the build stage uses to create module instances that the host application ultimately consumes.\r\n\r\n> Modifying module meta objects is the primary responsibility of the different pipelines.\r\n\r\nThe basic shape looks like this, but plugin handlers are free to add more data to it.\r\n\r\n- **`deps`** { Array[ string ] } - Collection of module names a particular module depends on. Used by the `dependency` stage.\r\n- **`name`** { string } - Name of the module to load. Used by `resolve` to figure out the `path`.\r\n- **`path`** { string } - Path for the module file. Used by `fetch` to load the module file.\r\n- **`source`** { string } - File content of the module.  Use by `transform` to transpile the module content.\r\n- **`referrer`** { { string: path, string: name } } - Information about the module requesting to load the current module.\r\n\r\n#### Pipeline Flow of the first and second stage\r\n\r\n* first stage (fetch stage) *async*\r\n  * create moduleMeta\r\n  * resolve (moduleMeta)\r\n    * calculate module path from moduleMeta.name and set moduleMeta.path\r\n  * fetch (moduleMeta)\r\n    * read module file using moduleMeta.path and set moduleMeta.source\r\n  * transform (moduleMeta)\r\n    * run custom transforms and set moduleMeta.source\r\n  * dependency (moduleMeta)\r\n    * parse out dependencies from moduleMeta.source and set moduleMeta.deps\r\n    * recursively feed each item in moduleMeta.deps through the first stage\r\n  * precompile (moduleMeta)\r\n    * optionally builds and sets moduleMeta.exports, which prevents the build stage from processing the particular module\r\n\r\n* second stage (build stage) *sync*\r\n  * compile - evalutes moduleMeta.source\r\n  * link - calls factory, creates module instance, and sets module.exports\r\n\r\n\r\n#### Visual of fetch pipelines\r\n\r\n<img src=\"img/bit-loader-fetch-pipelines-white.png\" width=\"100%\"></img>\r\n\r\n\r\n## Pattern Matching\r\n\r\nPattern matching rules allow you to define which modules are processed by `bit-loader`. This is accomplished by defining `match`, `ignore`, and `extensions` rules, which can be defined in plugins and in plugin handlers. You can also specify `ignore` rules in `bit-loader` instances. This combination gives you lots of control over what parts of your setup can process particular modules.\r\n\r\n- `match` and `ignore` rules are objects whose properties are matched against properties in module meta objects. For example, if you have a `match` rule object with a property called `path`, then the `path` in module meta will be tested to determine if the particular module meta can be processed.\r\n\r\n- `extensions` rules is a strings or array of strings to match the file extension of the module being loaded.\r\n\r\n> `bit-loader` pattern matching rules are an abstraction on top of [roolio](https://github.com/MiguelCastillo/roolio), so feel free to explore different matching rules, including custom ones. But generally, you will only specify strings and regexp.\r\n\r\n### match\r\n\r\n> match rules define which modules are *processed* by bit-loader.\r\n\r\nThe following example sets a `match` rule in a plugin to only process modules that have `src/views` in the path.  All other modules are ignored by this plugin.\r\n\r\n``` javascript\r\nvar Bitloader = require(\"bit-loader\");\r\nvar bitloader = new Bitloader();\r\n\r\nbitloader.plugin({\r\n  match {\r\n    path: /src\\/views/\r\n  },\r\n  transform: [\r\n    function(meta) {\r\n      console.log(meta.name);\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\nExpanding on the previous example, we set a `match` rule for a particular plugin handler so that it only processes modules with names that end in `region`. This basically tells the plugin that it can only process modules in `src/views` and that the particular transform can only process modules with names that end in `region`.\r\n\r\n``` javascript\r\nvar Bitloader = require(\"bit-loader\");\r\nvar bitloader = new Bitloader();\r\n\r\nbitloader.plugin({\r\n  match {\r\n    path: /src\\/views/\r\n  },\r\n  transform: [\r\n    {\r\n      match: {\r\n        name: /region$/\r\n      },\r\n      handler: function(meta) {\r\n        console.log(meta.name);\r\n      }\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n### ignore\r\n\r\n> ignore rules define which modules are *ignored* by bit-loader.\r\n\r\n`ignore` rules are defined exactly the same way as `match` rules. You configure `ignore` rules if you want particular plugins and plugin handlers as well as `bit-loader` instances to ignore certain modules.\r\n\r\nThe following example tells `bit-loader` to ignore modules with the name `react` and `jquery`.\r\n\r\n``` javascript\r\nvar Bitbundler = require(\"bit-bundler\");\r\nvar bitbundler = new Bitbundler({\r\n  ignore: {\r\n    name: [\"react\", \"jquery\"]\r\n  }\r\n});\r\n```\r\n\r\n> You can alternatively use the short form `ignore: [\"react\", \"jquery\"]` when configuring ignore rules for bit-loader instances.\r\n\r\nBy default, ignore rules in bit-loader instances will prevent the `transform` and `dependency` pipelines from processing modules. You can further customize which pipelines ignore which modules by specifying a `services` array with the names of the pipelines that ought to skip module processing. The valid pipelines are `resolve`, `fetch`, `transform`, `dependency`, and `precompile`.\r\n\r\nThe following example illustrates how to configure a plugin so that it ignores all modules in `src/views`\r\n\r\n``` javascript\r\nvar Bitloader = require(\"bit-loader\");\r\nvar bitloader = new Bitloader();\r\n\r\nbitloader.plugin({\r\n  ignore {\r\n    path: /src\\/views/\r\n  },\r\n  transform: [\r\n    function(meta) {\r\n      console.log(meta.name);\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n### extensions\r\n\r\n> extensions rules defines which modules with particular file extensions can be processed by *bit-loader*\r\n\r\n`extensions` rules are a shortcut for defining pattern matching rules for module meta paths with regular expressions to test for file extensions.  E.g. `match: { path: /\\.(js|jsx)$/gmi }`.  But extension matching is such a common use case that making this simpler is very convenient.\r\n\r\n> `extensions` rules are case insensitive.\r\n\r\n``` javascript\r\nvar Bitloader = require(\"bit-loader\");\r\nvar bitloader = new Bitloader();\r\n\r\nbitloader.plugin({\r\n  extensions: [\"js\", \"jsx\"],\r\n  transform: [\r\n    function(meta) {\r\n      console.log(meta.path);\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n\r\n## License\r\n\r\nLicensed under MIT\r\n\r\n<!--\r\n## Reference diagrams\r\n\r\n### Loader diagram\r\n<img src=\"https://raw.githubusercontent.com/MiguelCastillo/bit-loader/master/img/Loader.png\" alt=\"Loader diagram\" height=\"600px\"></img>\r\n\r\n### Fetch diagram\r\n<img src=\"https://raw.githubusercontent.com/MiguelCastillo/bit-loader/master/img/Loader-Fetch.png\" alt=\"Fetch diagram\" height=\"600px\"></img>\r\n\r\n### Pipeline diagram\r\n<img src=\"https://raw.githubusercontent.com/MiguelCastillo/bit-loader/master/img/Loader-Pipeline.png\" alt=\"Pipeline diagram\" height=\"600px\"></img>\r\n-->\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}